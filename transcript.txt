56

- [Man] Hi, and welcome back to the course.

In this video, we're going to be installing Flask.

Flask is a library that works with our Python installation

and is what's going to let us create our REST APIs.

Python is really great for installing libraries,

because it's really easy to instal libraries

as long as the library has been enabled

to work with the central library management system

in Python.

This central system is accessed via a command called pip.

Pip is what allows us to easily instal libaries in Python.

There are other ways of installing libraries, too,

but fortunately Flask works with pip,

so it's really easy.

Normally, you should just use pip.

However, because some students may have

multiple Python versions installed,

if you do pip only,

that will instal packages and libraries

in your Python 2.7 installation

if you have Python 2.7 installed.

Therefore, I recommend you do pip 3.5 instal flask.

And apologies, "flask" with a lowercase. That's important.

pip3.5 instal flask.

When we do this, we're gonna instal Flask

for our Python installation,

and this is gonna be the latest version of Flask.

So just press enter, and then that will instal it.

In my case, I've already got it installed,

so it's saying requirement already satisfied,

but when you run pip3.5 instal flask,

it will instal six different libraries,

Flask being one of them, Werkzeug being another one,

itsdangerous, click, jinja2, and MarkupSafe,

little really useful parts of Flask,

and we will explore them in due time.

Once that's done, you're ready to continue,

so congratulations.

Now let's go back into atom,

and let's create our first Flask application.

I'll see you there.

57

Access the code for this section here
Hello!

You may access the code in this section here: https://github.com/schoolofcode-me/rest-api-sections/tree/master/section3

Remember, it's always a great idea to type the code, rather than copy-paste it.

Write the code alongside the video, and use the code above to check for mistakes and to refresh your memory.

Kind regards,

Jose

58

- [Instructor] Hi, and welcome back.

In this video, we're going to create

our first flask application.

Flask applications are built around requests and responses.

Now, we're going to look very in detail

at what requests and responses are

and how the web works in the next couple of videos.

But I want to give you a quick introduction (pause) now.

Apologies for that.

A request is what your browser does.

So, for example, safari,

or google chrome, or internet explorer.

Whenever you go to a website, you're making a request.

And there is a computer somewhere on the internet

that is receiving that request.

And that computer has something

like a flask application in it.

So that flask application receives that request

from your browser, and then decides what to do with it,

and then returns back a response.

For example, one request may be

to ask for a certain page's home page.

Another request may be to ask

for something called hello.html for an html file.

Another request may be to ask

for user number three, for example.

So requests can be really anything.

But the server, the flask application,

has to be created to be able to understand those requests.

So that's the key here.

In order to start with our flask application,

the first thing we have to do

is to tell python that we want to use flask.

That kind of makes sense.

So the first thing to do is to say from flask, lowercase f,

import Flask, with an uppercase F.

Also let's use this opportunity to save this as app.py.

Once again, you can call this whatever you want,

but normally flask applications are called app.py.

And we will look at why in a few video's time, really.

Now that we've imported flask,

we've imported something called Flask with a capital F

from a package called flask with a lowercase f.

You may not have noticed, but classes in python,

such as our student and our working student classes

from last section, classes always start with a capital F.

And packages always start with a lowercase f,

although we've not really seen this in practise.

We can therefore safely assume that Flask

with a capital F is a class.

And indeed it is.

So the first thing we want to do

is create an app from that Flask class.

So we're going to say app equals flask.

And here comes something a bit newer,

which is underscore underscore name, underscore underscore.

So that's two underscores in front and two behind.

And the underscore underscore name, underscore underscore

is a special python variable.

It essentially gives each file a unique name.

And that's really all that we have to worry about.

So when we start the Flask application,

in order for Flask to know that this application

is running in a specific unique place,

we tell it this underscore underscore name

underscore underscore.

Don't worry much about it.

Then, the first thing we have to say

is to tell our app what requests it's going to understand.

Remember, earlier I said that sometimes

you may request the homepage of an application.

Other times you may request something like a hello.html.

Other times you may request the third user,

or things like that.

So we have to tell our app exactly

what request it will understand.

And it can understand many requests, of course,

but we're going to start with just one.

In order to do that, we're going to use a decorator.

So now we know what those are.

It's going to say @app.route and here is going to go

the route or the endpoint or the request

that it is going to understand.

In our case, it is going to be a forward slash

within a string.

And what this means is,

for example, http://www.google.com/.

So when you access a webpage such as google.com,

really what you're accessing is google.com/.

And the forward slash there just means

this is the homepage of the site.

You can also do things like google.com/maps, I think.

And this would be a separate route.

You can do google.com/plus, I think.

I'm not really familiar with google's end points.

But this would be a separate end point, slash plus.

Because they are supposed to do different things

in a server.

So if you leave it just as a forward slash,

that is the home page of the application.

And as we know, a decorator always has to act on a method,

so what's going to come after is going to be a method.

In this case I'm calling the method home.

But the name of the method in Flask does not matter,

so you can call it whatever you want.

All that matters is this route.

So now we've got our home method,

we can make it do things.

And whatever it does,

it has to return a response back to our browser

so that our browser receives something back

and it can show something on the website.

So for example, we're going to return "Hello, world!".

So what's going to happen now

is that when we access our end point with our browser,

what we should see is "Hello, world!" coming back.

And then we also, of course, have to tell the app

to start running.

So let's do that, app.run.

And here we can tell it a specific port.

A port is just a sort of area of the computer

where your app is going to be receiving your requests

and returning your responses through.

Computers have many of these areas,

and in my case I'm going to use port 5000.

If you do receive an error when you run the app,

saying address already in use,

that's because some other application in your computer

is already using this port.

So all you have to do is just change it

for something else, like 4999, for example.

Okay, once that's done, let's go into the terminal.

I'm going to clear this.

And making sure that you are in the correct folder,

which in my case, I don't think I am,

so I'm going to go in it,

code, section three, video code.

Making sure you're in the correct folder,

then do python3.5 app.py.

And what you should see is something like this.

Running on and here is the interesting part,

http://127.0.0.1:5000/,

and the forward slash is important

because that's the home page of our app.

The 5000, as you can imagine,

is the port that we've selected,

and 127.0.0.1, for those of you who are

experienced programmers, you'll know what that is,

but for those of you that don't,

that is your computer.

So 127.0.0.1 is a special IP address

that is reserved for your computer, specifically.

So whenever you access this address in your browser,

what you're accessing is your own computer.

Because we're accessing using http,

that means that our browser is able to access this page.

So just copy that and go into chrome, for example.

And then let's paste it in.

And what we see is "Hello world!" coming back

because that's what our end point returns.

Notice how google chrome strips

the trailing slash from the end.

But that's always present there,

and some other browsers will not remove it.

So just because google chrome removes it,

doesn't mean we're not accessing the home page.

And that's our hello, world.

And this was your first flask application.

And you've managed to create an end point

that returns some data.

So going back to atom, all that we've done

is imported Flask, created an object of Flask

using a unique name, and then created a route,

which was for the home page of our application,

just the forward slash,

assigned a method to it, which has to return something,

and whatever it returns will go to the browser.

And finally we've ran the app.

Of course, these methods don't have

to return strings only.

That would be quite boring.

But normally in rest API's they do return strings,

and it is a Javascript application

that deals with displaying things nicely.

Flask can also display things nicely if we want,

but that's not the purpose of this course.

There is many, not many,

but there are a couple other courses, one of them mine,

that deals with creating web sites and web apps with Flask.

This course is concerned with rest APIs.

And rest APIs usually return text in a specific format.

So we're going to be looking at more of that

in the next coming sections.

But in this section we are going to give you a bit

of insight into how you might use a rest API

from within a Javascript application.

For those of you that are interested

in using your API from within Javascript,

that will be very useful.

So the next couple of videos are going to be

more about how the web works,

how rest works, and things like that.

And then we'll move on to creating

the Javascript programme that will use this API

just for your convenience.

So hopefully all that's okay,

and I'll see you in the very next video.

59

- [Instructor] Hi and welcome back to the course.

In this video we're going to look at HTTP Verbs.

HTTP is one of the most popular protocols,

one of the most popular ways of creating

interactions and allowing interactions

between two internet connected elements

such as your computer and another computer.

The first thing we wanna look at is what is a web server?

This course is all about creating web servers, so I think

that kinda gives you a bit of a hint.

Now, a web server has many definitions.

One of them is it's a piece of hardware

like a computer is.

Another definition is that it is a piece of software

and this piece of software is designed to accept

incoming web requests.

Now, if this sounds like Chinese which I hope it doesn't,

it doesn't sound completely foreign.

Let's have a look at what web requests are as well.

But first, a quick example.

Google has many web servers.

And whenever we go to http://www.google.com

in our browser, such as Google Chrome or Safari,

what we're doing is we're sending something

to one of their web servers.

We don't know which web server, but we know it's

one of them.

And when we send something to the web server

the web server can then decide to respond back.

It may not respond, as we'll see in a moment.

So, what is it that we send to these web servers?

Well, when we go to http://www.google.com

we send exactly the following, this is what

the web server sees.

So, when a user such as ourselves, accesses

the Google home page one of their servers somewhere

receives this piece of information.

Get/http/1.1, and the host is www.google.com.

So, what does this mean?

Well, this is what's called the get request

and the server just sees that, get/http/1.1

and the host name which is not here.

So, the get is called a verb.

It tells the server to some extent, what we think

the server is going to return.

So, what is expected of the server.

The slash is the path, which is what we want

out of the server.

Finally, http/1.1 is the protocol and this is

the most popular http protocol, but now

we're also experimenting with http/2 as well

which is a faster and more efficient version.

So, this is really all the server sees

and when we create our own web server applications

we're going to see something very similar.

So, what?

Is that everything?

Well actually, yeah.

That's all the server sees

and the server sees that and then there's some code

and the code is what the server runs on and that allows

it to make a decision as to what it's going to respond with.

So, different servers may interpret the get request

in many different ways and they'll respond differently.

For example, the server may give you an error

if the path is not found.

In this case the forward slash.

It may give you an error if http is not supported.

For example, if it's a mail server and only supports

SMTP, or if it's an FDP server and so on.

It may give you an error if a server

is currently unavailable.

But, it may not also give you errors, it may also give you

useful stuff such as a HTML code, which is

what it normally does at least in Google's case.

It may also give you some text.

It may give you nothing if the server is not configured

to give you anything, then it just won't

give you anything back.

So, what else?

Well, going to any page with your browser such as Chrome

or Safari or Firefox will always do the same.

It's always going to do a get request.

So, here's a couple examples.

For example, going to the login on Twitter page

which is https://twitter.com/login.

That performs the get request get/login.

Ad you can see, up to the .com is the host name

and anything after that is the path,

what we are requesting.

So, in this case, the host is https://twitter.com

and the path is /login, which is what comes after.

Similarly for this other page, we are requesting

/download/mac and you can see that Google Chrome

has a nice colour and it tells us what the different

parts are just by looking at the colour of it.

A lot of browers don't do the same, which is

a bit of a shame.

And finally, google.co.uk, the host is

https://www.google.co.uk and the path

in this case is just the forward slash.

By now you may have realised that the forward slash

is the root, the sort of home page if you wish.

And so, when we just go to a page that normally

just requests the home page and then normally

there's just a forward slash.

So, the differences between these three servers

aren't just on what the server responds with.

Every server sees it, essentially identical requests

requesting different paths granted.

But, the only difference is what the server

responds with and in Twitter's case they respond with

the Twitter login HTML page and the

get scm case they respond with the get scm

downloads for Mac HTML page and in Google's case

they respond with the main Google home page

which seems fairly obvious, but really when we create

our own web servers that's, we're gonna see exactly

the same as they do, but we're gonna respond

with slightly different HTML code.

So, what I want you to realise is there's

no magic going on here.

All the server is seeing is the piece of data coming in

and then it's responding with another piece of data

and these servers all work in the same way.

So, what else?

Well, going to a web page will always do a get request.

No matter where you go, the server's always gonna see

the same thing.

That's because the browser, such as Chrome or Safari

is configured to do a get request whenever it accesses

a page, but there's also many other things

that we can do such as, host instead of get.

We can do delete, we can do put, options, head

and there's many more actually.

And once again, this is just a piece of data

that we're sending the server and the server

then can respond differently to each,

but they normally have the same meaning

for each server.

So, all servers will respond to a post request

in similar ways.

All servers will respond with delete requests

in similar ways.

In the same way that all servers respond to a get request

in a similar way.

That's because these things are so widely used

that they have nearly become a standard now.

So, the crux of this lesson is the HTTP Verbs.

So, here's what they normally mean, which doesn't mean

that they will always mean this, but it does mean

that this is a fairly common meaning.

So, for the get normally means to retrieve something.

For example, when you go to the Google home page

you're retrieving the Google home page.

In the case of an API you may do something like

get/item/1 and that presumably retrieves

an item identified by 1.

So, one may be the item's ID or something like that.

You nay do a post, which for the server means

receive data and use it, doesn't really tell you how

it's gonna use it, but presumably if you do post/item

that may create a new item see.

Also, when you do a post request normally

you have to send some data along the post request.

We're gonna look at how to do that

and basically in this case may be a piece of Jason

which is name and prize and then presumably

the server would create an item called

chair with price 9.99, presumably

and we don't know unless we look at the code.

A put request means, make sure that something is there.

Notice how it doesn't say create things

or do anything, it just makes sure that something is there.

So if you do put/item with some data again,

that may create a new chain to make sure

that the chair exists.

Or, if the chair's already there, it may update

the chair, change the price.

Again, to make sure whether that item is there,

but unless the put request allows for duplication

then that's what it'll do.

First it'll create it and then will update it.

And finally, we can also do delete, which tends

to mean remove something such as delete/item/1

and presumably that would delete the item

with ID number one.

Now, we've looked at four of the most important

HTTP Verbs, but there are many others and we

won't be looking at those in this course,

but nevertheless, it's worth knowing

that there are other types of HTTP Verbs

that we can use.

So, that's everything for this video.

I wanted to introduce you to the concept of the way

the web works and how these HTTP Verbs behave

because in the next video we're gonna look

at HTTP, sorry, at rest APIs and these verbs

are gonna come in really handy there.

So, without further adieu, I'll see you

in the very next video.

60

- [Instructor] Hi and welcome back to the course.

In this video we're going to look at REST principles

and this is really important.

This lecture may be slightly confusing

and it's slightly abstract,

and please do ask questions at any point

if you have any questions at all.

Let's look at what we know now about HTTP.

Going to a site performs a GET request

and this normally returns HTML,

but it may return other things,

such as text for example or errors,

and also we can do things other than GET.

We can do POST for example.

Okay, so this is what we know already.

Now let's look at what a REST API is.

A REST API uses those same concepts that we've looked at

GET, POST, and so on

so there's no technical things going on in a REST API.

All that at REST API is or rather all that REST is

is a way of thinking

about how a web server responds to your requests

and how a web server behaves in general.

It doesn't respond with just data.

It responds with something called resources.

Now a resource is essentially just data,

but it's a shift in the way of thinking.

So we must stop thinking about

we ask the server something

and the server responds with data

and now we have to start thinking about

we are asking for a resource, for a thing in the server.

It's very similar to object-oriented programming.

So we can think of the server as having resources

and each resource is able to interact

with the pertinent request.

We're going to look at what the pertinent request is now.

So let's say we have this GET

endpoint, our server has been programmed

to be able to receive this

GET request/item/chair.

It also has been programmed to

receive this POST request/item/chair

with some extra data

and such as to create a new chair for example.

It also has been programmed to accept this request

PUT/item/chair presumably also with some extra data

so it can create or update the chair,

and also it can deal with the DELETE/item/chair.

As you can see all of these four requests

have the same endpoint /item/chair.

That's because they are all accessing the same resource.

The chair element of the item resource.

So this could be the item resource,

and whenever we interact with an item

we know that the endpoint is going to be the same.

Now we can start thinking of

our interactions with the server

as not individual requests, but resources,

and now we can do things like GET a resource

or POST something to the resource

or create a resource, delete a resource and so on.

Which simplifies the way of thinking,

simplifies the thought process behind these interactions,

because now instead of dealing with just

individual endpoints

we're dealing with something a bit larger.

So once again, similar to object-oriented programming.

In object-oriented programming objects

are just things that hold some data

and then some more data in the form of methods

and they have a name

and here it's really a similar thing.

Another endpoint may be GET/items,

and that we can probably see the similarity.

Items and item probably fairly related,

but it's a different endpoint

and we're no longer retrieving an individual resource,

/items probably means we're retrieving multiple items,

therefore, it cannot be the item resource.

It must be something like an item list resource for example.

In this section we're going to look at creating these too

programmatically.

Another key feature of REST

is that it is stateless

or it is supposed to be stateless.

Now stateless is always really confusing initially.

But all that it means is that one request

cannot depend on any other requests.

And again this may be confusing.

As we programme this will make more sense.

So the server only knows about the current request

and not about any previous requests.

Let me give you a couple examples.

For our first example image we create a

chair item.

We create a request that is POST/item/chair

and presumably that creates a chair.

The server doesn't know the item now exists.

It has created it, it has put it in a database,

and then its forgot about it because its

sent us a response back, it said

item created for example,

and then it's forgotten that the items exists,

but it is in the database.

When we do GET/item/chair

the server cannot say okay this exists.

It has to go to the database,

check to see if it exists,

and then return the item to us

if it does exist or an error otherwise.

So as you can see this sort of makes sense,

but the server doesn't know that the item exists

it has to do the full check,

go to the database and check it.

So to GET an item

you don't have to have created the item before.

We could just do the GET request

and then that would go to the database

and see if the item is there.

So it doesn't require the POST request

to have happened before.

Okay, so this is one example here's another example

that is going to be really useful this section.

Say a user logs into a web application, for example Twitter.

When we do that the server responds with some data

and that data is going to be really important.

That data is going to be unique to this user.

And once it does that the server doesn't know

the user is logged in since it doesn't have any state.

So what do we do?

Well remember that piece of unique data

the server returned when we logged in?

The web application has to send that data

every time it interacts with a server

so that the server can see

okay I sent this data earlier,

this user is indeed logged in,

because the data is unique.

And that data had to be sent in every request

or else the server won't be able to associate

the request with the user.

This authentication we're going to implement in this section

and everything is going to make a lot more sense.

So if this is confusing

don't worry because it is always confusing initially.

The first time I learned about REST

I though what the hell is stateless

and it didn't really make sense for a long time.

So don't worry if it is confusing.

As I said as we programme the APIs

a lot of these things will make sense,

because they just do

so they'll come naturally to you,

and always ask questions at anytime

and I'm always available to help and guide you

personally if you need anything.

So don't doubt, go to the course Q&A

and ask questions away if you need anything.

So that's everything for this video we've looked at REST

and what it means and essentially it means

that we are now dealing with resources

and we're dealing with

stateless servers.

So we're going to implement a REST API in this section.

So I hope you enjoy that

and that's it for this video

so I'll see you on the next one.

61

- [Narrator] Hi, and welcome back to the course.

Remember our simple Flask application?

Now, we're going to extend that to show the endpoints

that we looked at in the very last presentation.

We're going to simulate an online store using Flask.

There were a couple of things that we discussed.

Net post was used to receive data,

and the get was used to, essentially, send data back only.

Remember, from the browser's perspective,

this is the opposite.

The browser will use post to send us data.

And it will use get to receive data.

But here, we are not a browser, we are a server.

So, when we receive a post request,

that means we are receiving some data,

and therefore we have to deal with it.

And when we receive a get request,

that means that we have to send data back.

For example, when we receive post store,

and that means that we have to probably create a store.

We may receive get store, and that means

we have to send back a list of stores.

So, the endpoints that we're gonna create

are post for store, and this is,

the data that we're gonna receive is a name.

We're gonna create get of store,

slash string name.

Get for stores, we're gonna create post

for a store string, oh, apologies,

string name item.

And also get for store string name item.

So, what these endpoints are gonna do

is, the first one is gonna create a new store

with a given name.

The second one is going to get a store for a given name,

and it's gonna return some data about it.

The third one is going to return a list of all the stores.

The fourth one is going to create an item

inside a specific store, with a given name.

And the last one is gonna get all the items

in a specific store.

This one will also have a name and a price, for example.

OK.

So, I'll create an example of a post request

and a get request for you,

and then we, I'll expect you to create the rest.

So, for the first port request.

Well, we know how to create an endpoint.

It is @app.root, and here, before we put a forward slash,

that was the root of our application, the home page,

now we wanna put it as slash store,

because that is what this endpoint is.

Therefore, our browser, or our web application,

or our m, whoever is really calling our API

is going to call this endpoint.

However, it has to be a post.

By default, when you use app.route,

that is a get request.

And browsers, by default, only do get requests.

So, we're gonna need to say comma methods equal post.

So, this defines our route as being slash store,

and as being accessible only via a post request.

If we want it to be accessible via a get request, as well,

then we could do post and get.

So then, this endpoint could be called

either via post or via get.

We will look at how that works later on in the course.

Then, we have to associate a method with it.

And in this case, I'm gonna call the method create store.

And it's not going to do anything for now,

but we will make it do stuff later on.

To get the store, well, fairy simple.

I'm sure you can do it yourself.

So, if you think you can, pause the video now

and give it a go.

And if not, just keep watching and I will implement it here.

To get a store, we'll have app.route slash store,

slash string name.

This is a special Flask bit of syntax,

which means that when we get store,

when we create our method,

our method can have a parameter, which is name.

This name here has to match this one here.

And therefore, when we receive a request

such as an http://107.0.0.1/5000/store/some_name,

some name is going to be this name here.

So, the name variable will contain some name.

If we have a store that has that name,

we're gonna be able to return it, using that as a key.

OK.

So, this is also going to pass.

And then, you know, this is just going to apply

for, really, the rest of them.

And this one is only store, so it doesn't

need the string name.

And also, it's not gonna have a parameter.

For the post, we're going to copy this one here,

and it's gonna have string name slash item.

Make sure to not forget any of these little bit

of syntax there, because that can be quite confusing

for Flask if you do that.

And finally, we're going to have something like this,

down here.

Remember to change the method names, as well,

because they have to be unique.

So, I'm gonna call this method get item store,

because that's essentially what this is going to do.

This is going to retrieve all the items

in a specific store.

For this one, it's going to be create item in store.

For this one, it is gonna get stores,

and this one is gonna be get store.

This one is gonna be create store.

So, these are our endpoints.

So, we've got our five endpoints now,

as we discussed in the last presentation.

And all we have to do now is really implement them.

So, how do we implement them?

Well, we, first of all, need a way to store our stores.

So, that can be, for example, something like a list.

And our stores can be an empty list initially,

and then it can have a dictionary in it,

and the dictionary is gonna have a name,

and the name's gonna be, for example,

My Wonderful Store.

And there's also gonna have a list of items,

and each item is going to have a name,

such as My Item and a price, such as 15.99.

OK.

So, hopefully this makes sense.

I'm just gonna clean this up a bit for you,

so it's a bit easier to understand or to know.

OK.

So, our store's list is going to contain a list

of dictionaries.

So, here we've got one dictionary, but we could have many.

Each dictionary has a name, such as our stores do,

and the name, in this case, is My Wonderful Store.

And it also has a list of items.

And in this case, items is a list.

So, we can have many other dictionaries in here,

and each dictionary is going to have a name

and a price.

We could do this with object oriented programming,

if we wanted, and we're gonna explore

how to do that later on, of course.

And also, normally, we would be storing these things

to a database, but in order to simplify things

and just teach you the basics of RS API,

we're gonna stick to having a dictionary here, in memory.

So, hopefully that's all right.

And in the next video, we're going to look

into implementing these endpoints.

So, I'll see you there.

62

- [Instructor] Hi and welcome back to the course.

I'm really excited to get started with

creating this REST API.

In order to create the REST API, we're gonna have

to go though a couple of steps.

Remember we've got a list of stores

and we're starting this list with a single store in it

and that's for a specific reason.

Creating a store is slightly more complicated

than retrieving a store.

So, what we're gonna do is we're gonna start

with retrieving all our stores

and that's gonna be the first endpoint we're going

to implement and that we're gonna test here in this video.

Then, we're gonna move on to the others.

The first thing we have to do is to understand one thing,

which is what JSON is.

Now, for those of you that are more experienced,

I'm sure you already know what JSON is,

but I'll just quickly explain it.

JSON is, essentially, a dictionary.

Something like this.

So, JSON is a set of key value pairs,

just like a dictionary is and it's really useful

to send data from one application to another.

For example, our Javascript application might request a list

of stores and they come back as a JSON

and then we can sort of look at each dictionary

and retrieve some data from it, just like we do in Python.

So, JSON is really useful

to send data between applications

and it looks pretty much just exactly like this.

However, JSON is not a dictionary.

JSON is text.

It is a long string.

So, our application has to return a string

in this format.

And then Javascript has to read that and deal with it,

as a string, maybe convert it

to a Javascript, sort of, dictionary, between quotes,

and then deal with it like that.

So, there has to be some sort of conversion

between a dictionary, which is a Python thing,

and a string, which is something

that we can send over the internet.

So, we cannot send a Python dictionary to Javascript,

because Javascript wouldn't understand it,

but Javascript does understand what text is

and it can do its own conversion there.

Fortunately, Flask really helps us out here

with a method called jsonify, which takes in a dictionary

and converts it JSON, which is a string in this format.

All we have to do is go to the very top of our file

and say from flask import flask, jsonify.

And that is a method that we're gonna need.

Notice how it's lower-case, because it's not a class.

It is a method.

So, let's go down into our stores.

This get_stores method that is going

to return all our stores.

And what we're going to do is

we're gonna say return jsonify(stores).

Remember, what this is gonna do is it's going

to convert the stores variable into JSON.

There is one last small problem,

which is that JSON is a dictionary

and our stores variable is not a dictionary.

It is a list.

JSON cannot be a list.

But we wanna return not a single store,

but a dictionary with all our stores.

So, what we do is we say jsonify

and we make this into a dictionary.

Stores is stores, like that.

So this is now our dictionary, which has one key only,

which is stores and that key has a value associated with it,

which is our list of stores.

This is our variable that we declared up there.

And that's all in our dictionary, so we jsonify that

and we return that to the person making the request.

So, let's save the app.py.

Let's go over to our terminal.

Make sure that we're in the right place.

So, in my case, the folder is up here.

/user/jslvtr/code/section3/video_code

So, let's go there.

And then let's do python3.5 app.py.

So now notice we are running.

Copy that.

Go over to your browser of choice.

Paste it in and make sure to say /store.

So, what do you think is gonna happen, when we press enter?

What are we going to see on our page?

Try to create a mental image as to what's gonna come out.

So, this is what we see.

A JSON representation of our stores.

Remember, we've got a dictionary with one key called stores

and that is a list.

This is our variable.

And that list has one element in it, one dictionary,

and that has a name down here and a list of items.

Remember dictionaries are not ordered,

because they are sets.

So, the items in this case has appeared first,

even though in our code, the name is first.

So this is what a REST API really, really does.

It returns JSON, after doing some processing.

So, for example, the REST API we're developing will allow us

to create stores, create items, and return them,

and things like that.

It would, for example, be very useful for a mobile app

that has been created to represent a store.

The mobile app could call our API and store stores

and items, so that the mobile app can then retrieve them

and so on.

So, what we've got here is something very specific,

which is the list of stores that we started our programme with

and also they're in JSON format and we can tell that they're

in JSON format, as opposed to a Python dictionary,

because of the double quotes.

JSON always uses double quotes and never single quotes.

That's a very important thing in JSON, so remember that.

Always double quotes, never single quotes.

And it always has to start with a dictionary,

so you cannot return a list only.

So, that's everything for this video.

We've implemented our first endpoint and,

in the next video, we're gonna implement the rest

and that's gonna include creating the stores and the items.

It's not gonna be too challenging, so you can give it a go

if you want and, if not, then I'll see you

in the very next video.

63

- [Instructor] Hi and welcome back to the course.

In this video we're going to be creating new stores,

using our API.

However, we're not going to be able to test

the creation of stores,

using our JavaScript application,

because, that gets slightly more complicated,

and this is not a JavaScript course.

However,

there is another way of testing the API

and we are gonna do that

the right way really.

We normally wouldn't test the API

using JavaScript,

we would test it using a specific API testing tool,

but we will still look at using the API

from within JavaScript

and then we will look at testing the API afterwards.

Anyway, for this video,

we're going to create a new store.

And the first thing we have to do,

is to be able to access the data that is coming back

to us from the request.

So the browser,

or the API testing tool,

is gonna send us some data,

the name of the store,

and we have to be able to access that data.

So the first thing we have to do

is go up to our first line of code,

and we're going to import something else.

We're gonna import flask,

JSONify,

and also request.

Request without an s at the end.

There's also a thing called requests.

And that's a different package.

So from flask we want to import request.

And then in the create store,

what we wanna do is say

request data is equal to request dot get JSON.

This request is the request that was made

to this endpoint.

So when the browser sends us the request

to create a new store,

this request is that one.

And the browser will also send us some

JSON data.

Which is the name of the store.

So this is going to allow us to get that data back.

Then we're gonna create a new store,

which is gonna be a dictionary

with a name,

where the name is request data name,

because that's gonna be the JSON.

When we do get JSON,

and this method already converts the JSON string

into a python dictionary,

so we can access it like that.

And also it's going to have a set of items

which is going to be an empty list.

We're then going to do stores that dot append,

and append our new store.

And finally we're going to return

the new store that we've created.

Just so the browser can understand that we

have indeed created this store.

So how would we return the new store.

I'm sure you got it.

Return, JSONify,

of new store.

It's important to include JSONify,

because if not,

we will try to return a dictionary

and that will fail because we have to return a string.

Okay, so this is how we would create a new store.

And as I said,

over the next few videos we're going to be testing

this out with JavaScript,

but we will not be able to test the

creation of stores with JavaScript,

that gets too complicated,

so we're going to test it with a different tool,

and that tool is what we use

professionally very very often.

So it's good for you to learn that as well.

To retrieve a specific store,

well, all we wanna do is go over the stores,

finding the one that matches this name,

and return that one.

So I will write a wee comment here,

iterate over stores,

if the store name matches,

return that one.

If none matches, return an error message.

And I think you can pause the video at this point

and give this a go.

Because you know how to iterate,

you know how to check using an if statement,

and you know how to return a store.

So go ahead and do that,

I would definitely recommend that you try that now.

Hopefully you gave it a go,

and what I would do is to iterate over stores,

for store in stores, stores remember is our variable,

and then I would say,

if the store name is equal to name,

which is the one that we're receiving here,

then return the store,

return JSONify of store.

Remember, store is a dictionary,

so we can just return that store directly,

and if no store matches,

we want to return some sort of error message,

such as message, store not found.

That's just to tell whoever's calling the API,

that there was indeed some sort of error.

Okay, now you can do the same thing

for the get store slash name slash item.

I'm sure you can go ahead and implement this now

yourself, now that you know how the other one works.

Hopefully you managed,

the way I would do it is actually very similar,

for store in stores, if the stores name matches,

then we're going to return the items in that store,

so we're going to return a JSONify of items.

Where that's the stores items.

And also if we don't find anything,

we're going to return the appropriate error message.

Like so.

Finally, the most challenging in point,

is the create item.

I'm sure that you can do this as well.

If you give it a bit of thought

and you look at how we've created a store above,

in a create store method,

you can do a very similar thing

to create an item.

Once again I would recommend pausing the video

and giving this a go.

But then I always recommend that,

so you may be ignoring this recommendation by now,

hopefully not.

So pause the video and give it a go

and then we'll do it here.

Hopefully you were successful,

and what I would do is,

once again,

for store in stores,

if the store name matches our name,

then we're going to create a new item,

that item is going to be one with a name

which is going to be the request data name,

and with a price which is going to be the request.

Oh, sorry,

price like that, and request data.

Price.

Naturally, you may have already realised the request data

doesn't exist in this method,

so we have to create it.

Request data,

equal request dot get JSON.

Like so.

So this is our new item there,

and what we wanna do is append it,

so store, items, dot append new item.

And then at the end,

new item,

at the end we can return a JSONify,

of the store,

or if you prefer, you can return JSONify

if new item that may be also an option.

It's totally up to you what you want to return

or up to your API rather.

Also at the end,

we wanna return an error message,

if we didn't find the store.

Something to keep in mind

is that if we return an item here,

that terminates the method

and we don't return this message.

We will only return this message

if we go through every store,

and we never return anything.

So if we start on our first store,

and the name does not match,

we will just skip all of this code,

and we will move onto the next store.

And if the name doesn't match,

we will skip all of that code

and we will go on to the next one,

and eventually if none of them match,

we will never have ran this code here,

so we will just exit the loop,

and return this error message at the end.

Okay.

Perfect.

So these are our end points,

now in the next video,

I've got an HTML file for you to download,

that has some boiler plate code,

and then we're gonna use that

to kinda test this out a bit and

look at how you can run

some JavaScript code in this API,

and after that we're going to,

properly test this API using a professional tool.

Which is free as well.

So don't worry about paying anything.

So without further ado,

I'll see you in the next video, with some JavaScript.

64

- [Jose] Hi, and welcome back to the course.

In this video, we're quickly going to go over

how you might call the API from within Javascript.

In the Resources section for this lecture

you've got an HTML file that you can download.

That should be somewhere at the top left

of your video player.

All I want you to do is download that HTML file,

create a templates folder, and put the HTML file in it.

It's very important that your folder

is called templates, because that's what

Flask is going to look for.

The HTML file looks like this,

and all it really does is call the API endpoint.

So we've got a HTML code,

which looks like these opening and closing tags.

This is an opening tag,

and this is a closing tag,

with the forward slash in front.

It's got a head tag, and a body tag.

The body is what we show our users,

and the head has some scripts and things

that we want to run,

but we don't want to show our users.

In the head, we put a JavaScript script,

and there is a function.

This function calls a URL using a GET request,

and then when it's done, it calls something else

that we define.

This is not a JavaScript course,

so apologies for the lack of detail in this,

but I just wanted to show you

that you can call your API from JavaScript,

and that it's really useful for web APIs,

for web applications, and things like that.

And also, now that we're here,

I'll also show you how you can render HTML code

from within your Flask application.

That's not something that you would want to do

from a REST API.

But it's something that you do want to do

if you want to create a Flask web application,

as opposed to a web API.

The first thing we have to do,

is to go to Flask and import 'render_template',

as well as the other things.

And then we're going to create another endpoint,

such as the 'home', that is going to return

a render_template of 'index.html'.

Flask automatically looks into the templates folder,

so this index.html is going to be this file here.

Okay, so when we render the template,

all we're going to see is the words 'Hello, world!',

because they are inside this div.

And a div is just an HTML element

that contains other elements.

In this case, it contains some text.

Although this JavaScript function is defined,

it's never going to run,

because we're not actually running it.

The same way as in Python,

defining a function doesn't run it,

in JavaScript defining a function

doesn't run it either.

So what we're going to do is,

we're going to run this app,

and we're going to go to the root of the app,

and we're going to see the words,

'Hello, world!', come out.

So let's go over to our terminal,

and do 'python3.5 app.py'.

Remember, you have to be in the correct folder to do this.

And then your app will start running.

So copy that, go over to Google Chrome,

paste it in here,

and what we get is 'Hello, world!'.

Remember, we're accessing the root endpoint,

but we can still access the store endpoint

if we want, and it still returns our json code.

What we're returning here is the JavaScript

and HTML code.

However, remember we've not called

the Javascript function which creates the GET request,

so that's something that we should do.

So let's do that now.

Below the function, say 'httpGetAsync',

and then the URL that we want to call,

and finally a callback function.

So a function that is going to get executed

once the request is successful.

This is very similar to passing functions

to functions in Python.

So what we're going to do here

is this.

The function callback also receives

the response content.

So that will be some JSON string.

And what we're going to do in this function,

is we're just going to throw an alert

with the response.

Okay, let's go over to the terminal,

stop this using Control + C and restart it,

and then go over to Chrome and refresh the page.

What do you think is going to happen?

We get our alert.

And this alert contains the JSON content,

essentially the string with this data here.

There are many other thing we could do

from JavaScript at this point.

We could, for example, go more in depth,

and create an element for each store.

Maybe have a list of the items that it contains.

We could do more interactive things,

like be able to click on a store

to retrieve the items, and so on.

There's loads of things that we could do.

But the key point here

is that I wanted to show you how

JavaScript and the API work together.

JavaScript always has to call your API

using some code like this.

In other cases you can use, for example,

AngularJS, or you can use jQuery.

There's a bunch of JavaScript libraries

that can do this for you.

But JavaScript is always running on the browser,

and it has to call your API to retrieve data from it,

so that it can then show it on the website.

So Python doesn't really know about the website

in the same way that JavaScript

doesn't know about the Python code.

But they talk to each other via our API,

by passing JSON code.

Again, this is not a JavaScript course,

so for more information I'd advise you go to

a JavaScript web application development course.

I have one of those,

but there are also many others in Udemy,

and elsewhere in the internet,

that talk about this stuff.

This was a simple tutorial on how

the JavaScript and Python code interact,

but there are many other things

that you can do with JavaScript,

so don't feel limited to displaying alerts.

There's many, many more things you can do.

And indeed the point of JavaScript

is to make websites more dynamic.

So that's it for this video.

And we've not tested the API, really.

We've only shown you how it works,

and in the next video we're going to actually

test the API properly and professionally,

using an API testing tool.

So I'll see you there.

65

- [Instructor] Hi and welcome back.

In this video we're going to be getting a professional tool

for API testing that's really awesome.

It's called Postman and you can

get it the getpostman.com/apps.

When you get to the website, you will see

something more or less like this.

I see a Main button here which is download Postman for Mac,

but I'm assuming that if you're on Windows

you'll see download Postman for Windows.

So just download Postman for your appropriate platform

such as Windows, Linux or Mac and instal it

like any other normal application and then we can run it.

If you prefer, you can run Postman from within Chrome

as an add-on, you can do that as well

if that's what you like doing instead.

Once you've downloaded it and run it

you will see something that looks like this.

It'll be slightly different because I've already

got some stuff here, but what you'll see

is a window that looks more or less like this.

So you'll have your runner, import

and a few buttons up here.

You'll have a team library which will not be accessible,

and also you'll have your stuff up here.

You'll have to sign up to get here first,

but that's sort of a given with any application these days.

Then what I want you to do is create

a new folder here, and I've called it REST API course,

but you can call it whatever you want.

Your collection, give it a nice name, it's usually better.

Okay, and then in here, you can create folders

I created a folder called section three

because this is the section we're in.

I would recommend you do that as well.

It'll be very useful later on for you

to have these collections to bring your memory back

if you forget things.

Then we're going to go over to the main sort of content.

This API testing tool let's us make requests

and as you can see the first button here is get.

We can change that and we can use any

of the other available HTTP verbs, GET, POST,

but also, PUT, PATCH, DELETE, COPY, HEAD, OPTIONS,

and many more.

In this API we've only used GET and POST,

we will use others as the course progresses.

Then we have to enter the request URL,

so that's gonna be HTTP://107.0.0.1:5000/store.

Once again, this is your local computer

this is the port that you're running on

and this is the endpoint we're accessing.

Then you've got a blue button called Send.

Don't know why I said green there.

A blue button called Send and when you press that

that will execute the request, do make sure, however,

to have your server running, so I'm gonna make sure

that it is running, that's the latest version

and then you can press Send.

And what you get back is your API content.

So exactly as we would expect.

Once that's done you can also press Save

to remember this request, normally I save my requests

just as the endpoint name, and save it

to the appropriate collection and press save.

Now you've got it here, and you can easily

go back to it at any point.

Now what I would recommend you do now

is to press the three buttons here, the three dots,

and press Duplicate, then make sure

to go into that endpoint.

If you then go and change this one and then you press save,

it will be over written and you will lose

the other endpoint, so just make sure

to keep duplicating these endpoints as you go along.

This endpoint we're going to call /store/My Wonderful Store.

Which, as you remember, is what we've got

in our stores list as our first store.

So let's press Send.

And as you can see we get back the data

that we would expect from this store.

So that's really great, we can see that it is working.

Once again, press Save to make sure

that this endpoint is saved and then you can,

once again. press the three buttons,

the three dots, and press Edit

and give this a nicer name, such as /store/name.

Then go ahead and duplicate that.

Go over to the new store and for example,

we can access item, we can see

that we get the items for this store back.

Once again press Save, edit this one,

give it an appropriate name and that's that.

Now we have created our three GET requests

and these are not really the problem.

These are just really accessing a URL

and then we get some data back.

Now, the more interesting bit is when it comes to creating.

So let's duplicate the GET store, go over to that endpoint

and change the GET to POST.

Now when we run this, we will get an error.

As you can see this is an internal server error

because we have not sent it the data that it expects.

We have to send it some JSON data, and using JavaScript

that's slightly more complicated and out of

the scope of this course but using Postman it's really easy.

Remember to save your endpoint first.

Change the name to it's more reasonable.

Let's go over to the headers and a header of a request

is the first thing that gets analysed by the server.

So the first thing that flask is going to do

when it receives a request, it is gonna look

at the headers to try and understand

sort of what this request is.

In the headers we can say things like

what sort of data, what type of data we're sending.

So this is a set of key value pairs and the first header

is going to be Content-Type and the value

is going to be application/json.

Now, when we send a request with this header

the server is going to be expecting JSON code

to be in the body.

So we're going to go to the body

and we're going to select raw.

Notice how because we've got a header, Postman automatically

selects JSON from this drop-down list.

But there are many other types of data we can send.

We're also going to look in the future

at what form data and what x-www-form-urlencoded are.

But, don't worry about those for now.

In the body, because we're creating a store

the only thing we need is the store name.

So remember, JSON always uses double quotation marks,

so that's "name": "Another store"

and this is all the data we need in our body.

So let's see of this and press Send.

And there you can see we get the

new store returned as you would expect.

Let's go and look at our code.

And the new store dictionary returns

a new store with a new name and an empty items list.

We append that to the stores and then

we return the new store.

And that's indeed what we've got here.

Remember to save the request then go to your GET store

and when you press Send should we be expecting

the new store to come out?

Yes we should, and indeed we have here our stores list

and there have the first store and the second store.

Now let's go over to our last endpoint.

Duplicate the GET store name item

and I'm going to change it to a post

I'm gonna save it, edit the name,

and then we are once again

gonna do the same thing.

So what's the first thing we have to do?

That's right, set the header

to be content-type application/json

and then the body to be raw.

And here we're going to set the name of the item

to be another item, price, and this

is going to be a decimal so just 10.99.

Save and Send, and we get an internal server error

so we've evidently done something wrong.

So what to do now is go over to the terminal,

look at the errors and we've made a small error

somewhere in the pass so this is the trace back,

it's a lot longer than it used to be.

At the very bottom, we see the error name.

NameError: is the name, 'request data' is not defined.

Directly above the error, we see

the line of our code that went wrong.

This is the file app.py line 51

and we see request_data equal equal request.get_json.

Do you spot the error there?

It's easy to make small typos while recording

but nevertheless is gonna be very useful

the problem is that equal equal is used for comparison

such as here, whereas a single equal is used for assignment.

So that was the small error there,

make sure to restart your server,

and then run Postman again.

And there we get our other item.

Something to remember though, we've restarted the server

so when we get our list of stores,

what do you think is gonna come out?

Our two stores or one store?

And this is the problem, we're only gonna get

one store back because whenever we restart the server

we lose the applications memory,

and therefore the stores variable gets deleted.

When we start the server again,

the stores variable gets set to this list again,

which only has one store.

Obviously the solution to that is

to store things permanently in a database or in a file.

Over the next few sections, we are going to look

into how to store things into a database.

That seems fairly useful for a REST API

to be able to do, so we're going to look

into SQLAlchemy to easily and efficiently store

our resources such as our stores

and our items to a database.

So this is Postman.

Postman is extremely useful for testing API's

I cannot stress that enough, I use this thing everyday

at work and I know most people do as well.

It's because it just let's you have

all your API endpoint's here and whenever you

make a change to one of them, or whenever you want

to verify that something works the way you expect,

you just go in here and run the endpoint.

Then you can check that the data returned is correct,

the thing is coming back as opposed to giving you an error

and things like that, so it's really essential

that whenever you're creating REST API's

you keep all your endpoints here so you

can test them as you go along.

That's everything for this video.

Hopefully you learned something about

how software developers work professionally

with REST API's and I'll see you in the very next one.

66

- Hi, congratulations on finishing this section on Flask.

Hopefully it served to raise some understanding

on how the web, and Flask, and Python work together.

Understanding the web and these building blocks

is really important to understanding REST APIs.

Remember, a REST API is going to be an interface

between your programme and other programmes that call your API.

Understanding the building blocks, therefore,

is going to be essential for you to understand

how other programmes interact with your API.

In this section, we looked at Flask, and in the next one,

we're going to be looking at creating real performing

and complying REST APIs with Flask

and also a popular extension.

I'll see you in the very next section.