56

- [Man] Hi, and welcome back to the course.

In this video, we're going to be installing Flask.

Flask is a library that works with our Python installation

and is what's going to let us create our REST APIs.

Python is really great for installing libraries,

because it's really easy to instal libraries

as long as the library has been enabled

to work with the central library management system

in Python.

This central system is accessed via a command called pip.

Pip is what allows us to easily instal libaries in Python.

There are other ways of installing libraries, too,

but fortunately Flask works with pip,

so it's really easy.

Normally, you should just use pip.

However, because some students may have

multiple Python versions installed,

if you do pip only,

that will instal packages and libraries

in your Python 2.7 installation

if you have Python 2.7 installed.

Therefore, I recommend you do pip 3.5 instal flask.

And apologies, "flask" with a lowercase. That's important.

pip3.5 instal flask.

When we do this, we're gonna instal Flask

for our Python installation,

and this is gonna be the latest version of Flask.

So just press enter, and then that will instal it.

In my case, I've already got it installed,

so it's saying requirement already satisfied,

but when you run pip3.5 instal flask,

it will instal six different libraries,

Flask being one of them, Werkzeug being another one,

itsdangerous, click, jinja2, and MarkupSafe,

little really useful parts of Flask,

and we will explore them in due time.

Once that's done, you're ready to continue,

so congratulations.

Now let's go back into atom,

and let's create our first Flask application.

I'll see you there.

57

Access the code for this section here
Hello!

You may access the code in this section here: https://github.com/schoolofcode-me/rest-api-sections/tree/master/section3

Remember, it's always a great idea to type the code, rather than copy-paste it.

Write the code alongside the video, and use the code above to check for mistakes and to refresh your memory.

Kind regards,

Jose

58

- [Instructor] Hi, and welcome back.

In this video, we're going to create

our first flask application.

Flask applications are built around requests and responses.

Now, we're going to look very in detail

at what requests and responses are

and how the web works in the next couple of videos.

But I want to give you a quick introduction (pause) now.

Apologies for that.

A request is what your browser does.

So, for example, safari,

or google chrome, or internet explorer.

Whenever you go to a website, you're making a request.

And there is a computer somewhere on the internet

that is receiving that request.

And that computer has something

like a flask application in it.

So that flask application receives that request

from your browser, and then decides what to do with it,

and then returns back a response.

For example, one request may be

to ask for a certain page's home page.

Another request may be to ask

for something called hello.html for an html file.

Another request may be to ask

for user number three, for example.

So requests can be really anything.

But the server, the flask application,

has to be created to be able to understand those requests.

So that's the key here.

In order to start with our flask application,

the first thing we have to do

is to tell python that we want to use flask.

That kind of makes sense.

So the first thing to do is to say from flask, lowercase f,

import Flask, with an uppercase F.

Also let's use this opportunity to save this as app.py.

Once again, you can call this whatever you want,

but normally flask applications are called app.py.

And we will look at why in a few video's time, really.

Now that we've imported flask,

we've imported something called Flask with a capital F

from a package called flask with a lowercase f.

You may not have noticed, but classes in python,

such as our student and our working student classes

from last section, classes always start with a capital F.

And packages always start with a lowercase f,

although we've not really seen this in practise.

We can therefore safely assume that Flask

with a capital F is a class.

And indeed it is.

So the first thing we want to do

is create an app from that Flask class.

So we're going to say app equals flask.

And here comes something a bit newer,

which is underscore underscore name, underscore underscore.

So that's two underscores in front and two behind.

And the underscore underscore name, underscore underscore

is a special python variable.

It essentially gives each file a unique name.

And that's really all that we have to worry about.

So when we start the Flask application,

in order for Flask to know that this application

is running in a specific unique place,

we tell it this underscore underscore name

underscore underscore.

Don't worry much about it.

Then, the first thing we have to say

is to tell our app what requests it's going to understand.

Remember, earlier I said that sometimes

you may request the homepage of an application.

Other times you may request something like a hello.html.

Other times you may request the third user,

or things like that.

So we have to tell our app exactly

what request it will understand.

And it can understand many requests, of course,

but we're going to start with just one.

In order to do that, we're going to use a decorator.

So now we know what those are.

It's going to say @app.route and here is going to go

the route or the endpoint or the request

that it is going to understand.

In our case, it is going to be a forward slash

within a string.

And what this means is,

for example, http://www.google.com/.

So when you access a webpage such as google.com,

really what you're accessing is google.com/.

And the forward slash there just means

this is the homepage of the site.

You can also do things like google.com/maps, I think.

And this would be a separate route.

You can do google.com/plus, I think.

I'm not really familiar with google's end points.

But this would be a separate end point, slash plus.

Because they are supposed to do different things

in a server.

So if you leave it just as a forward slash,

that is the home page of the application.

And as we know, a decorator always has to act on a method,

so what's going to come after is going to be a method.

In this case I'm calling the method home.

But the name of the method in Flask does not matter,

so you can call it whatever you want.

All that matters is this route.

So now we've got our home method,

we can make it do things.

And whatever it does,

it has to return a response back to our browser

so that our browser receives something back

and it can show something on the website.

So for example, we're going to return "Hello, world!".

So what's going to happen now

is that when we access our end point with our browser,

what we should see is "Hello, world!" coming back.

And then we also, of course, have to tell the app

to start running.

So let's do that, app.run.

And here we can tell it a specific port.

A port is just a sort of area of the computer

where your app is going to be receiving your requests

and returning your responses through.

Computers have many of these areas,

and in my case I'm going to use port 5000.

If you do receive an error when you run the app,

saying address already in use,

that's because some other application in your computer

is already using this port.

So all you have to do is just change it

for something else, like 4999, for example.

Okay, once that's done, let's go into the terminal.

I'm going to clear this.

And making sure that you are in the correct folder,

which in my case, I don't think I am,

so I'm going to go in it,

code, section three, video code.

Making sure you're in the correct folder,

then do python3.5 app.py.

And what you should see is something like this.

Running on and here is the interesting part,

http://127.0.0.1:5000/,

and the forward slash is important

because that's the home page of our app.

The 5000, as you can imagine,

is the port that we've selected,

and 127.0.0.1, for those of you who are

experienced programmers, you'll know what that is,

but for those of you that don't,

that is your computer.

So 127.0.0.1 is a special IP address

that is reserved for your computer, specifically.

So whenever you access this address in your browser,

what you're accessing is your own computer.

Because we're accessing using http,

that means that our browser is able to access this page.

So just copy that and go into chrome, for example.

And then let's paste it in.

And what we see is "Hello world!" coming back

because that's what our end point returns.

Notice how google chrome strips

the trailing slash from the end.

But that's always present there,

and some other browsers will not remove it.

So just because google chrome removes it,

doesn't mean we're not accessing the home page.

And that's our hello, world.

And this was your first flask application.

And you've managed to create an end point

that returns some data.

So going back to atom, all that we've done

is imported Flask, created an object of Flask

using a unique name, and then created a route,

which was for the home page of our application,

just the forward slash,

assigned a method to it, which has to return something,

and whatever it returns will go to the browser.

And finally we've ran the app.

Of course, these methods don't have

to return strings only.

That would be quite boring.

But normally in rest API's they do return strings,

and it is a Javascript application

that deals with displaying things nicely.

Flask can also display things nicely if we want,

but that's not the purpose of this course.

There is many, not many,

but there are a couple other courses, one of them mine,

that deals with creating web sites and web apps with Flask.

This course is concerned with rest APIs.

And rest APIs usually return text in a specific format.

So we're going to be looking at more of that

in the next coming sections.

But in this section we are going to give you a bit

of insight into how you might use a rest API

from within a Javascript application.

For those of you that are interested

in using your API from within Javascript,

that will be very useful.

So the next couple of videos are going to be

more about how the web works,

how rest works, and things like that.

And then we'll move on to creating

the Javascript programme that will use this API

just for your convenience.

So hopefully all that's okay,

and I'll see you in the very next video.

59

- [Instructor] Hi and welcome back to the course.

In this video we're going to look at HTTP Verbs.

HTTP is one of the most popular protocols,

one of the most popular ways of creating

interactions and allowing interactions

between two internet connected elements

such as your computer and another computer.

The first thing we wanna look at is what is a web server?

This course is all about creating web servers, so I think

that kinda gives you a bit of a hint.

Now, a web server has many definitions.

One of them is it's a piece of hardware

like a computer is.

Another definition is that it is a piece of software

and this piece of software is designed to accept

incoming web requests.

Now, if this sounds like Chinese which I hope it doesn't,

it doesn't sound completely foreign.

Let's have a look at what web requests are as well.

But first, a quick example.

Google has many web servers.

And whenever we go to http://www.google.com

in our browser, such as Google Chrome or Safari,

what we're doing is we're sending something

to one of their web servers.

We don't know which web server, but we know it's

one of them.

And when we send something to the web server

the web server can then decide to respond back.

It may not respond, as we'll see in a moment.

So, what is it that we send to these web servers?

Well, when we go to http://www.google.com

we send exactly the following, this is what

the web server sees.

So, when a user such as ourselves, accesses

the Google home page one of their servers somewhere

receives this piece of information.

Get/http/1.1, and the host is www.google.com.

So, what does this mean?

Well, this is what's called the get request

and the server just sees that, get/http/1.1

and the host name which is not here.

So, the get is called a verb.

It tells the server to some extent, what we think

the server is going to return.

So, what is expected of the server.

The slash is the path, which is what we want

out of the server.

Finally, http/1.1 is the protocol and this is

the most popular http protocol, but now

we're also experimenting with http/2 as well

which is a faster and more efficient version.

So, this is really all the server sees

and when we create our own web server applications

we're going to see something very similar.

So, what?

Is that everything?

Well actually, yeah.

That's all the server sees

and the server sees that and then there's some code

and the code is what the server runs on and that allows

it to make a decision as to what it's going to respond with.

So, different servers may interpret the get request

in many different ways and they'll respond differently.

For example, the server may give you an error

if the path is not found.

In this case the forward slash.

It may give you an error if http is not supported.

For example, if it's a mail server and only supports

SMTP, or if it's an FDP server and so on.

It may give you an error if a server

is currently unavailable.

But, it may not also give you errors, it may also give you

useful stuff such as a HTML code, which is

what it normally does at least in Google's case.

It may also give you some text.

It may give you nothing if the server is not configured

to give you anything, then it just won't

give you anything back.

So, what else?

Well, going to any page with your browser such as Chrome

or Safari or Firefox will always do the same.

It's always going to do a get request.

So, here's a couple examples.

For example, going to the login on Twitter page

which is https://twitter.com/login.

That performs the get request get/login.

Ad you can see, up to the .com is the host name

and anything after that is the path,

what we are requesting.

So, in this case, the host is https://twitter.com

and the path is /login, which is what comes after.

Similarly for this other page, we are requesting

/download/mac and you can see that Google Chrome

has a nice colour and it tells us what the different

parts are just by looking at the colour of it.

A lot of browers don't do the same, which is

a bit of a shame.

And finally, google.co.uk, the host is

https://www.google.co.uk and the path

in this case is just the forward slash.

By now you may have realised that the forward slash

is the root, the sort of home page if you wish.

And so, when we just go to a page that normally

just requests the home page and then normally

there's just a forward slash.

So, the differences between these three servers

aren't just on what the server responds with.

Every server sees it, essentially identical requests

requesting different paths granted.

But, the only difference is what the server

responds with and in Twitter's case they respond with

the Twitter login HTML page and the

get scm case they respond with the get scm

downloads for Mac HTML page and in Google's case

they respond with the main Google home page

which seems fairly obvious, but really when we create

our own web servers that's, we're gonna see exactly

the same as they do, but we're gonna respond

with slightly different HTML code.

So, what I want you to realise is there's

no magic going on here.

All the server is seeing is the piece of data coming in

and then it's responding with another piece of data

and these servers all work in the same way.

So, what else?

Well, going to a web page will always do a get request.

No matter where you go, the server's always gonna see

the same thing.

That's because the browser, such as Chrome or Safari

is configured to do a get request whenever it accesses

a page, but there's also many other things

that we can do such as, host instead of get.

We can do delete, we can do put, options, head

and there's many more actually.

And once again, this is just a piece of data

that we're sending the server and the server

then can respond differently to each,

but they normally have the same meaning

for each server.

So, all servers will respond to a post request

in similar ways.

All servers will respond with delete requests

in similar ways.

In the same way that all servers respond to a get request

in a similar way.

That's because these things are so widely used

that they have nearly become a standard now.

So, the crux of this lesson is the HTTP Verbs.

So, here's what they normally mean, which doesn't mean

that they will always mean this, but it does mean

that this is a fairly common meaning.

So, for the get normally means to retrieve something.

For example, when you go to the Google home page

you're retrieving the Google home page.

In the case of an API you may do something like

get/item/1 and that presumably retrieves

an item identified by 1.

So, one may be the item's ID or something like that.

You nay do a post, which for the server means

receive data and use it, doesn't really tell you how

it's gonna use it, but presumably if you do post/item

that may create a new item see.

Also, when you do a post request normally

you have to send some data along the post request.

We're gonna look at how to do that

and basically in this case may be a piece of Jason

which is name and prize and then presumably

the server would create an item called

chair with price 9.99, presumably

and we don't know unless we look at the code.

A put request means, make sure that something is there.

Notice how it doesn't say create things

or do anything, it just makes sure that something is there.

So if you do put/item with some data again,

that may create a new chain to make sure

that the chair exists.

Or, if the chair's already there, it may update

the chair, change the price.

Again, to make sure whether that item is there,

but unless the put request allows for duplication

then that's what it'll do.

First it'll create it and then will update it.

And finally, we can also do delete, which tends

to mean remove something such as delete/item/1

and presumably that would delete the item

with ID number one.

Now, we've looked at four of the most important

HTTP Verbs, but there are many others and we

won't be looking at those in this course,

but nevertheless, it's worth knowing

that there are other types of HTTP Verbs

that we can use.

So, that's everything for this video.

I wanted to introduce you to the concept of the way

the web works and how these HTTP Verbs behave

because in the next video we're gonna look

at HTTP, sorry, at rest APIs and these verbs

are gonna come in really handy there.

So, without further adieu, I'll see you

in the very next video.

60

- [Instructor] Hi and welcome back to the course.

In this video we're going to look at REST principles

and this is really important.

This lecture may be slightly confusing

and it's slightly abstract,

and please do ask questions at any point

if you have any questions at all.

Let's look at what we know now about HTTP.

Going to a site performs a GET request

and this normally returns HTML,

but it may return other things,

such as text for example or errors,

and also we can do things other than GET.

We can do POST for example.

Okay, so this is what we know already.

Now let's look at what a REST API is.

A REST API uses those same concepts that we've looked at

GET, POST, and so on

so there's no technical things going on in a REST API.

All that at REST API is or rather all that REST is

is a way of thinking

about how a web server responds to your requests

and how a web server behaves in general.

It doesn't respond with just data.

It responds with something called resources.

Now a resource is essentially just data,

but it's a shift in the way of thinking.

So we must stop thinking about

we ask the server something

and the server responds with data

and now we have to start thinking about

we are asking for a resource, for a thing in the server.

It's very similar to object-oriented programming.

So we can think of the server as having resources

and each resource is able to interact

with the pertinent request.

We're going to look at what the pertinent request is now.

So let's say we have this GET

endpoint, our server has been programmed

to be able to receive this

GET request/item/chair.

It also has been programmed to

receive this POST request/item/chair

with some extra data

and such as to create a new chair for example.

It also has been programmed to accept this request

PUT/item/chair presumably also with some extra data

so it can create or update the chair,

and also it can deal with the DELETE/item/chair.

As you can see all of these four requests

have the same endpoint /item/chair.

That's because they are all accessing the same resource.

The chair element of the item resource.

So this could be the item resource,

and whenever we interact with an item

we know that the endpoint is going to be the same.

Now we can start thinking of

our interactions with the server

as not individual requests, but resources,

and now we can do things like GET a resource

or POST something to the resource

or create a resource, delete a resource and so on.

Which simplifies the way of thinking,

simplifies the thought process behind these interactions,

because now instead of dealing with just

individual endpoints

we're dealing with something a bit larger.

So once again, similar to object-oriented programming.

In object-oriented programming objects

are just things that hold some data

and then some more data in the form of methods

and they have a name

and here it's really a similar thing.

Another endpoint may be GET/items,

and that we can probably see the similarity.

Items and item probably fairly related,

but it's a different endpoint

and we're no longer retrieving an individual resource,

/items probably means we're retrieving multiple items,

therefore, it cannot be the item resource.

It must be something like an item list resource for example.

In this section we're going to look at creating these too

programmatically.

Another key feature of REST

is that it is stateless

or it is supposed to be stateless.

Now stateless is always really confusing initially.

But all that it means is that one request

cannot depend on any other requests.

And again this may be confusing.

As we programme this will make more sense.

So the server only knows about the current request

and not about any previous requests.

Let me give you a couple examples.

For our first example image we create a

chair item.

We create a request that is POST/item/chair

and presumably that creates a chair.

The server doesn't know the item now exists.

It has created it, it has put it in a database,

and then its forgot about it because its

sent us a response back, it said

item created for example,

and then it's forgotten that the items exists,

but it is in the database.

When we do GET/item/chair

the server cannot say okay this exists.

It has to go to the database,

check to see if it exists,

and then return the item to us

if it does exist or an error otherwise.

So as you can see this sort of makes sense,

but the server doesn't know that the item exists

it has to do the full check,

go to the database and check it.

So to GET an item

you don't have to have created the item before.

We could just do the GET request

and then that would go to the database

and see if the item is there.

So it doesn't require the POST request

to have happened before.

Okay, so this is one example here's another example

that is going to be really useful this section.

Say a user logs into a web application, for example Twitter.

When we do that the server responds with some data

and that data is going to be really important.

That data is going to be unique to this user.

And once it does that the server doesn't know

the user is logged in since it doesn't have any state.

So what do we do?

Well remember that piece of unique data

the server returned when we logged in?

The web application has to send that data

every time it interacts with a server

so that the server can see

okay I sent this data earlier,

this user is indeed logged in,

because the data is unique.

And that data had to be sent in every request

or else the server won't be able to associate

the request with the user.

This authentication we're going to implement in this section

and everything is going to make a lot more sense.

So if this is confusing

don't worry because it is always confusing initially.

The first time I learned about REST

I though what the hell is stateless

and it didn't really make sense for a long time.

So don't worry if it is confusing.

As I said as we programme the APIs

a lot of these things will make sense,

because they just do

so they'll come naturally to you,

and always ask questions at anytime

and I'm always available to help and guide you

personally if you need anything.

So don't doubt, go to the course Q&A

and ask questions away if you need anything.

So that's everything for this video we've looked at REST

and what it means and essentially it means

that we are now dealing with resources

and we're dealing with

stateless servers.

So we're going to implement a REST API in this section.

So I hope you enjoy that

and that's it for this video

so I'll see you on the next one.

61




